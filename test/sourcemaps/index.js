var path = require( 'path' );
var assert = require( 'assert' );
var SourceMapConsumer = require( 'source-map' ).SourceMapConsumer;

var Promise = require( 'sander' ).Promise;

module.exports = function () {
	return new Promise( function ( fulfil ) {
		var esperanto, start, stats = {};

		describe( 'sourcemap', function () {
			this.timeout( 20000 );

			before( function () {
				if ( process.env.BUILD_TIMEOUT ) {
					this.timeout( parseInt( process.env.BUILD_TIMEOUT ) );
				}

				return require( '../utils/build' )().then( function ( lib ) {
					esperanto = lib;
					start = Date.now();
				});
			});

			after( function () {
				stats.total = Date.now() - start;
				fulfil( stats );
			});

			describe( 'standalone', function () {
				var sample, tests;

				sample = [
					'var answer = 42;',
					'console.log("the answer is %s", answer);'
				].join( '\n' );

				tests = [
					{ method: 'toAmd' },
					{ method: 'toCjs' },
					{ method: 'toUmd' }
				];

				tests.forEach( function ( t ) {
					it( 'is generated by ' + t.method, function () {
						var result, charIndex, acc, generatedLoc, smc, lines, line, loc, i;

						result = esperanto[ t.method ]( sample, {
							sourceMap: true,
							sourceMapFile: 'output.js',
							sourceMapSource: 'input.js',
							name: 'myModule'
						});

						// find the location of 'console' in the generated code...
						charIndex = result.code.indexOf( 'console' );
						acc = 0;

						lines = result.code.split( '\n' );
						for ( i = 0; i < lines.length; i += 1 ) {
							line = lines[i];
							if ( acc + line.length > charIndex ) {
								generatedLoc = {
									line: i + 1,
									column: charIndex - acc
								};

								break;
							}

							acc += line.length + 1;
						}

						// ...then ensure it corresponds to line 2 (one-based), column 0 (zero-based)
						smc = new SourceMapConsumer( result.map );
						loc = smc.originalPositionFor( generatedLoc );

						assert.equal( loc.line, 2 );
						assert.equal( loc.column, 0 );
					});
				});

				it( 'accepts an absolute path for sourceMapFile', function () {
					var result = esperanto.toAmd( sample, {
						sourceMap: true,
						sourceMapFile: '/path/to/output.js',
						sourceMapSource: 'input.js',
						name: 'myModule'
					});

					assert.ok( /sourceMappingURL=\/path\/to\/output.js/.test( result.code ) );
				});

				it( 'does not require a sourceMapFile for `sourceMap: "inline"`', function() {
					var result = esperanto.toAmd( sample, {
						sourceMap: 'inline',
						sourceMapSource: 'input.js',
						name: 'myModule'
					});
				});
			});

			describe( 'bundler', function () {
				it( 'should create sourcemap', function () {
					return esperanto.bundle({
						base: path.join( __dirname, 'bundle' ),
						entry: 'main'
					}).then( function ( bundle ) {
						var converted, smc, loc;

						converted = bundle.toCjs({
							sourceMap: true,
							sourceMapFile: path.join( __dirname, 'bundle.js' )
						});

						smc = new SourceMapConsumer( converted.map );

						loc = smc.originalPositionFor({ line: 3, column: 14 });

						assert.equal( loc.line, 1 );
						assert.equal( loc.column, 14 );
						assert.equal( loc.source, 'bundle/foo.js' );

						loc = smc.originalPositionFor({ line: 6, column: 8 });

						assert.equal( loc.line, 2 );
						assert.equal( loc.column, 8 );
						assert.equal( loc.source, 'bundle/main.js' );
					});
				});
			});
		});
	});
};
